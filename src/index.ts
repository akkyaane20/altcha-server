import { randomBytes } from 'node:crypto'
import { serve } from '@hono/node-server'
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { createChallenge, verifyFieldsHash, verifySolution, verifyServerSignature } from 'altcha-lib'
import { ServerSignatureVerificationData } from 'altcha-lib/types'

// Server configuration
const PORT = process.env.PORT || 3000
 
// Configure custom ALTCHA_HMAC_KEY if not set in environment variables
const ALTCHA_HMAC_KEY = process.env.ALTCHA_HMAC_KEY || randomBytes(16).toString('hex')
const ALTCHA_MAX_NUMBER = process.env.ALTCHA_MAX_NUMBER || '50000'

const CACHE_TTL = 15 * 60 * 1000
const CLEANING_CACHE_AUTO = 5 * 60 * 1000

//Cache : challengeCache[clientIP] = count
const challengeCache = new Map<string , CacheEntry>();
 
const app = new Hono()

function getClientIp(c: any): string {
  return c.req.header('x-real-ip')
}

function checkIfIpAlreadyInCache(ip: string): boolean{
  return challengeCache.has(ip);
}

function countIncrementationByIp(ip: string){
  const makeIncrementation = checkIfIpAlreadyInCache(ip)

  if(makeIncrementation){
    let currentEntry = challengeCache.get(ip)
    if(currentEntry){
      currentEntry.count += 1n
      currentEntry.lastAccess = Date.now()
    }
  }
  else{
    challengeCache.set(ip, {count: 1n, lastAccess: Date.now()})
  }

  return challengeCache.get(ip);
}

setInterval(() => {
  for (const [ip, lastEntry] of challengeCache.entries()){
    if(Date.now() - lastEntry.lastAccess > CACHE_TTL){
      challengeCache.delete(ip);
    }
  }
}, CLEANING_CACHE_AUTO)
 
// Apply CORS middleware to all routes
app.use('/*', cors())
 
// Root endpoint providing information about available endpoints
app.get('/', (c) => {
  return c.text([
    'ALTCHA server :',
    '',
    'GET /api/challenge - Challenge generation with paylaod',
    'POST /api/verify - Check validation payload',
    'GET /health - Check state altcha server'
  ].join('\n'))
})
 
/**
 * GET /altcha
 *
 * Endpoint for fetching a new random challenge to be used by the ALTCHA widget
 */
app.get('/api/challenge', async (c) => {
  try {
    let currentClientIp = getClientIp(c)
    let currentEntry = countIncrementationByIp(currentClientIp)


    if (currentEntry && currentEntry.count > 30n) {
        return c.json({
        error: 'Too many requests',
      }, 429)
    }

    // Generate a new random challenge with a specified complexity
    const challenge = await createChallenge({
      expires: new Date(Date.now() + 30000),
      hmacKey: ALTCHA_HMAC_KEY,
      maxnumber: Number(ALTCHA_MAX_NUMBER) + ((Number(ALTCHA_MAX_NUMBER) / 2) * Number(currentEntry?.count)),
    })

    // Return the generated challenge as JSON
    return c.json(challenge)
  } catch (error: any) {
    // Handle any errors that occur during challenge creation
    return c.json({
      error: 'Failed to create challenge',
      details: error.message
    }, 500)
  }
})

/**
 * POST /submit
 * 
 * Endpoint for form submissions that verifies the simple PoW challenge without the spam filter
 */
app.post('/api/verify', async (c) => {
  try {
    // Read form data from the request
    const data = await c.req.formData()
    
    // Get the 'altcha' field containing the verification payload from the form data
    const altchaResponseDTO: AltchaResponseDTO = {
      payload: data.get("payload") as string,
    };  

    // If the 'altcha' field is missing, return an error
    if (!altchaResponseDTO) {
      return c.json({
        error: 'Altcha payload missing',
      }, 400)
    }

    // Verify the solution using the secret HMAC key
    const verified = await verifySolution(String(altchaResponseDTO), ALTCHA_HMAC_KEY, true)

    // Verify the server signature returned by the API.
    const verifiedSignature = await verifyServerSignature(String(altchaResponseDTO), ALTCHA_HMAC_KEY)

    // Verifies the hash of form fields returned by the Spam Filter
    //const verifiedHash = await verifyFieldsHash()

    // If verification fails, return an error
    if (!verified && verifiedSignature) {//&& verifiedHash
      return c.json({
        error: 'Invalid Altcha payload',
      }, 400)
    }

    // Altcha payload successfully verified
    // Here you would process the form data

    // For demo purposes, return the form data and success status
    return c.json({
      success: true,
      data: Object.fromEntries(data),
    }, 202)
  } catch (error: any) {
    // Handle any errors that occur during submission processing
    return c.json({
      error: 'Failed to process submission',
      details: error.message
    }, 500)
  }
})

/**
 * POST /submit_spam_filter
 * 
 * Endpoint for form submissions that verifies the server signature generated by the spam filter
 */
app.get('/health', async (c) => {
  return c.json({
    status: 'ok',
    uptime: process.uptime(),       
    timestamp: new Date().toISOString(),
  });
});

// Log the server start message with the port number
console.log(`Server is running on port ${PORT}`)

// Start the server
serve({
  fetch: app.fetch,
  port: +PORT,
})

export interface AltchaResponseDTO {
  payload: string;
}

export interface CacheEntry{
  count: bigint;
  lastAccess: number;
}

export interface verifyServerSignature {
  verificationData: ServerSignatureVerificationData | null;
  verified: boolean;
}